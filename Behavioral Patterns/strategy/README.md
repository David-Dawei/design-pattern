# Strategy Pattern
Strategy Pattern定义一系列的算法，把它们一个个封装起来，并且使它们可相互替换。该模式使得算法可独立于使用它的客户而变化。策略模式为了适应不同的需求，只把变化点封装了，这个变化点就是实现不同需求的算法，但是，用户需要知道各种算法的具体情况。
Strategy模式和Template模式要解决的问题是相同（类似）的，都是为了给业务逻辑（算法）具体实现和抽象接口之间的解耦。具体实现时，将算法的逻辑抽象接口（DoAction）封装到一个类中（Context），再通过委托的方式将具体的算法实现委托给具体的Strategy类来实现（ConcreteStrategeA
类）。即Strategy：定义所有支持的算法的公共接口。Context使用这个接口来调用某ConcreteStrategy定义的算法；ConcreteStrategy：实现Strategy接口的具体算法；Context：使用一个ConcreteStrategy对象来配置；维护一个对Stategy对象的引用，同时，可以定义一个接口来让Stategy访问它的数据。
Strategy模式适用于以下情形：
- 许多相关的类仅仅是行为有异。“策略”提供了一种用多个行为中的一个行为来配置一个类的方法；
- 需要使用一个算法的不同变体；
- 算法使用客户不应该知道的数据。可使用策略模式以避免暴露复杂的、与算法相关的数据结构；
- 一个类定义了多种行为，并且这些行为在这个类的操作中以多个条件语句的形式出现。将相关的条件分支移入它们各自的Strategy类中以替代这些条件语句。
Strategy模式和Template模式解决了类似的问题，Strategy模式和Template模式实际是实现一个抽象接口的两种方式：继承和组合之间的区别。要实现一个抽象接口，`继承是一种方式`：我们将抽象接口声明在基类中，将具体的实现放在具体子类中。`组合（委托）是另外一种方式`：我们将接口的实现放在被组合对象中，将抽象接口放在组合类中。
继承：
- 优点
  - 易于修改和扩展那些被复用的实现。
- 缺点
  - 破坏了封装性，继承中父类的实现细节暴露给子类了；
  - “白盒”复用；
  - 当父类的实现更改时，其所有子类将不得不随之改变
  - 从父类继承而来的实现在运行期间不能改变（编译期间就已经确定了）
组合：
- 优点
  - “黑盒”复用，因为被包含对象的内部细节对外是不可见的
  - 封装性好
  - 实现和抽象的依赖性很小（组合对象和被组合对象之间的依赖性小）
  - 可以在运行期间动态定义实现（通过一个指向相同类型的指针，典型的是抽象基类的指针）
- 缺点
  - 系统中对象过多。

从上面对比中可以看出，组合相比继承可以取得更好的效果，因此在面向对象的设计中的有一条很重要的原则就是：优先使用（对象）组合，而非（类）继承（Favor Composition Over Inheritance）。实际上，继承是一种强制性很强的方式，因此也使得基类和具体子类之间的耦合性很强。例如在Template模式中在ConcreteClass1中定义的原语操作别的类是不能够直接复用（除非你继承自AbstractClass，具体分析请参看Template模式文档）。而组合（委托）的方式则有很小的耦合性，实现（具体实现）和接口（抽象接口）之间的依赖性很小，例如在本实现中，ConcreteStrategyA的具体实现操作很容易被别的类复用，例如我们要定义另一个Context类AnotherContext，只要组合一个指向Strategy的指针就可以很容易地复用ConcreteStrategyA的实现了。
另外，Strategy模式很State模式也有相似之处，但是State模式注重的对象在不同的状态下不同的操作。两者之间的区别就是State模式中具体实现类中有一个指向Context的引用，而Strategy模式则没有
