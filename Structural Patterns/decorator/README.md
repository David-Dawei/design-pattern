# Decorator Pattern
Decorator即饰者，装装顾名思义，就是在一个核心功能上添加一些附属功能，从而让核心功能发挥更大的作用，但是最终它的核心功能是不能丢失的。
Decorator模式采用`组合的方式`实现，其本质就是动态组合。利用这种模式可以给某个对象而不是整个类添加一些功能，其适用于以下场合：
- 接口的一致性；装饰对象的接口必须与它所装饰的Component的接口是一致的，因此，所有的ConcreteDecorator类必须有一个公共的父类；这样对于用户来说，就是统一的接口；
- 省略抽象的Decorator类；当仅需要添加一个职责时，没有必要定义抽象Decorator类。因为常常要处理现存的类层次结构而不是设计一个新系统，这时可以把Decorator向Component转发请求的职责合并到ConcreteDecorator中；
- 保持Component类的简单性；为了保证接口的一致性，组件和装饰必须要有一个公共的Component类，所以保持这个Component类的简单性是非常重要的，所以，这个Component类应该集中于定义接口而不是存储数据。对数据表示的定义应延迟到子类中，否则Component类会变得过于复杂和臃肿，因而难以大量使用。赋予Component类太多的功能，也使得具体的子类有一些它们它们不需要的功能大大增大；

装饰者模式与模式的区别：
桥接桥接模式的定义是将抽象化与实现化分离（用组合的方式而不是继承的方式），使得两者可以独立变化。但是二者还是有区别的：
- 桥接模式中所说的分离，其实是指将结构与实现分离（当结构和实现有可能发生变化时）或属性与基于属性的行为进行分离；而装饰者只是对基于属性的行为进行封闭成独立的类，从而达到对其进行装饰，也就是扩展。e.g.异常类和异常处理类之间就可以使用桥接模式来实现完成，而不能使用装饰模式来进行设计；如果对于异常的处理需要进行扩展时，我们又可以对异常处理类添加Decorator，从而添加处理的装饰，达到异常处理的扩展，这就是一个桥接模式与装饰模式的搭配
- 桥接中的行为是横向的行为，行为彼此之间无关联，注意这里的行为之间是没有关联的，e.g.异常和异常处理之间是没有行为关联的一样；而装饰者模式中的行为具有可叠加性，其表现出来的结果是一个整体，一个各个行为组合后的一个结果
