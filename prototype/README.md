# Prototype Pattern
Prototype模式提供了自我复制的功能，即新对象的创建可以通过已有对象进行创建。原型模式和建造者模式、工厂方法模式一样，都属于创建型模式的一种。以下场景适合使用原型模式：
- 当对象类型不是开始就能确定的，而这个类型是在运行期确定的话，那么通过这个类型的对象克隆出一个新的对象比较容易一些；
- 有的时候，需要一个对象在某个状态下的副本，此时，使用原型模式是最好的选择；例如：一个对象，经过一段处理之后，其内部的状态发生了变化；这个时候，需要一个这个状态的副本，如果直接new一个新的对象的话，但是它的状态是不对的，此时，可以使用原型模式，将原来的对象拷贝一个出来，这个对象就和之前的对象是完全一致的了；
- 当处理一些比较简单的对象时，并且对象之间的区别很小，可能就几个属性不同而已，那么就可以使用原型模式来完成，省去了创建对象时的麻烦了；
- 有的时候，创建对象时，构造函数的参数很多，而自己又不完全的知道每个参数的意义，就可以使用原型模式来创建一个新的对象，这样就可以不必去理会创建的过程了。

由于克隆需要一个原型，在Prototype定义克隆自身的Clone接口，由派生类进行实现，而实现原型模式的重点就在于这个Clone接口的实现。有的时候，当调用Clone获得了一个复制的对象以后，需要改变对象的状态，此时就可能需要在ConcretePrototype类中添加一个Initialize操作，专门用于初始化克隆对象。
由于在Clone的内部调用的是拷贝构造函数，而此处又涉及到`深拷贝和浅拷贝`的问题。
Prototype模式通过复制原型（Prototype）而获得新对象创建的功能，这里的Prototype本身就是一个对象工厂（因为它能够生产对象），实际上Prototype模式和Builder模式、AbstractFactory模式都是通过一个类（对象实例）来专门负责对象的创建工作（工厂对象），三者之间的区别是：

- 工厂方法模式适用于生产较复杂，一个工厂生产单一的一种产品的情形；抽象工厂模式适用于一个工厂生产多个相互依赖的产品；建造者模式着重于复杂对象的一步一步创建，组装产品的过程，并在创建的过程中，可以控制每一个简单对象的创建；原型模式则更强调的是从自身复制自己，创建要给和自己一模一样的对象。
  - Builder模式重在复杂对象的一步步创建（并不直接返回对象）；
  -  AbstractFactory模式重在产生多个相互依赖类的对象；
  - 而Prototype模式重在从自身复制自己创建新类。
