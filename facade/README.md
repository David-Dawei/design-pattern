# Facade Pattern
Facade模式即外观模式，Facade模式在高层提供了一个统一的接口，解耦了系统。e.g.
在使用IDE进行编译C++代码时，你只是在菜单中选择了Build，然后IDE就开始了一堆的编译工作；一个简单的Build动作，编译器会在后台会进行语法分析，生成中间代码，生成汇编代码，链接成可执行程序或库等等动作；而这一切，对开发者来说不用去理解编译器在做什么的，编译器隐藏了背后的一系列复杂操作，而只提供一个Build按钮，这个Build按钮，就可以执行一切的操作；当单击这个Build按钮时，Build在幕后，将任务分发给不同的子系统去完成，最终子系统进行协作完成了整个的编译任务。而这样隐藏一些复杂操作，只提供一个更高层的统一接口，就是外观模式。即`将子系统中的一组接口提供一个一致的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用`。
外观模式适用于以下场合：
- 当要为一个复杂子系统提供一个简单接口时。子系统往往因为不断演化而变的越来越复杂。大多数模式使用时都会产生更多更小的类。这使得子系统更具有可重用性，也更容易对子系统进行定制，但这也给那些不需要定制子系统的用户带来一些使用上的困难。外观模式可以提供一个简单的缺省视图，这一视图对大多数用户来说已经足够，而那些需要更多的可定制性的用户可以越过Facade层；
- 当客户程序与抽象类的实现部分之间存在很大的依赖性。引入Facade将这个子系统与客户以及其他的子系统分离，可以提高子系统的独立性和可移植性；
- 当需要构建一个层次结构的子系统时，使用外观模式定义子系统中每层的入口点。如果子系统之间是相互依赖的，我们就可以让它们仅通过Facade进行通讯，从而简化了它们之间的依赖关系。
